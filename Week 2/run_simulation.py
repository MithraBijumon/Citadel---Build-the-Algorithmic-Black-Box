# -*- coding: utf-8 -*-
"""run_simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wzmP8v2-31ESYl2vRRYK42M8R7hmlU79
"""

import heapq
import time
import random
import pandas as pd
import numpy as np
import itertools
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages

SEED = 42

random.seed(SEED)
np.random.seed(SEED)

"""A fixed random seed was used to ensure deterministic simulations and reproducible analytics.

Required Classes
"""

class Order:
    def __init__(self, order_id, side, price, qty, timestamp):
        self.id = order_id
        self.side = side        # 'buy' or 'sell'
        self.price = price
        self.qty = qty
        self.ts = timestamp

class OrderBook:
    def __init__(self):
        self.bids = []   # max-heap using negative prices
        self.asks = []   # min-heap
        self.trades = []
        self.tape = []
        self._seq = itertools.count()   # unique sequence number

    def add_order(self, order):
        seq = next(self._seq)
        if order.side == 'buy':
            # negative price → max-heap behavior
            heapq.heappush(self.bids, (-order.price, order.ts, seq, order))
        else:
            heapq.heappush(self.asks, (order.price, order.ts, seq, order))

        self.match()

    def match(self):
        while self.bids and self.asks:
            buy = self.bids[0][3]
            sell = self.asks[0][3]

            if buy.price < sell.price:
                break

            traded_qty = min(buy.qty, sell.qty)

            self.trades.append(
                (buy.id, sell.id, sell.price, traded_qty)
            )

            self.tape.append({
                "time": time.time(),
                "price": sell.price,
                "qty": traded_qty
            })


            buy.qty -= traded_qty
            sell.qty -= traded_qty

            if buy.qty == 0:
                heapq.heappop(self.bids)
            if sell.qty == 0:
                heapq.heappop(self.asks)

    def print_top5(self):
        print("\nBUY SIDE")
        for _, _, _, o in heapq.nsmallest(5, self.bids):
          print(o.price, o.qty)

        print("SELL SIDE")
        for _, _, _, o in heapq.nsmallest(5, self.asks):
          print(o.price, o.qty)

    def best_bid(self):
        return self.bids[0][3].price if self.bids else None

    def best_ask(self):
        return self.asks[0][3].price if self.asks else None

    def mid_price(self):
        if self.best_bid() is None or self.best_ask() is None:
            return None
        return (self.best_bid() + self.best_ask()) / 2

"""A unique sequence number was added to heap entries to guarantee total ordering and prevent Python from comparing Order objects directly. So that even if orders with the same price appear at the same time, heap does not have to compare the order objects"""

class Event:
    def __init__(self, time):
        self.time = time

    def process(self, engine):
        raise NotImplementedError

class OrderArrivalEvent(Event):
    def __init__(self, time, order):
        super().__init__(time)
        self.order = order

    def process(self, engine):
        engine.order_book.add_order(self.order)

class MarketCloseEvent(Event):
    def process(self, engine):
        engine.running = False

class SnapshotEvent:
    def __init__(self, time):
        self.time = time

    def process(self, engine):
        bb = engine.order_book.best_bid()
        ba = engine.order_book.best_ask()

        if bb is not None and ba is not None:
            engine.l1_snapshots.append({
                "time": engine.time,
                "best_bid": bb,
                "best_ask": ba,
                "spread": ba - bb,
                "mid": (ba + bb) / 2
            })

        depth = 3
        bids = [(o.price, o.qty) for _, _, _, o in heapq.nsmallest(depth, engine.order_book.bids)]
        asks = [(o.price, o.qty) for _, _, _, o in heapq.nsmallest(depth, engine.order_book.asks)]
        t = (bids, asks)
        engine.l2_snapshots.append(t)

class MarketEngine:
    def __init__(self, order_book):
        self.time = 0
        self.event_queue = []
        self.seq = 0          # tie-breaker
        self.order_book = order_book
        self.running = True
        self.l1_snapshots = []
        self.l2_snapshots = []

    def push_event(self, event):
        heapq.heappush(
            self.event_queue,
            (event.time, self.seq, event)
        )
        self.seq += 1

    def run(self):
        while self.event_queue and self.running:
            event_time, _, event = heapq.heappop(self.event_queue)

            # advance simulation time
            self.time = event_time

            # process event
            event.process(self)

"""Before Starting Simulations and Plotting"""

# -----------------------------
# PARAMETERS
# -----------------------------
NUM_ORDERS = 1000
SIMULATION_TIME = 600   # seconds (10 minutes)
BASE_PRICE = 100

# -----------------------------
# CREATE ENGINE
# -----------------------------
book = OrderBook()
engine = MarketEngine(book)

order_id = 0

# -----------------------------
# GENERATE 1000 RANDOM ORDERS
# -----------------------------
for _ in range(NUM_ORDERS):
    order_id += 1

    # random arrival time
    t = random.randint(0, SIMULATION_TIME)

    # random side
    side = random.choice(["buy", "sell"])

    # random price around base price
    price_offset = int(np.random.normal(0, 2))
    price = max(1, BASE_PRICE + price_offset)

    # random quantity
    qty = random.randint(1, 10)

    order = Order(
        order_id=order_id,
        side=side,
        price=price,
        qty=qty,
        timestamp=t
    )

    engine.push_event(OrderArrivalEvent(t, order))

# -----------------------------
# SNAPSHOTS EVERY 1 SECOND
# -----------------------------
for t in range(0, SIMULATION_TIME + 1):
    engine.push_event(SnapshotEvent(t + 0.0001))

# -----------------------------
# MARKET CLOSE
# -----------------------------
engine.push_event(MarketCloseEvent(SIMULATION_TIME + 1))

# -----------------------------
# RUN SIMULATION
# -----------------------------
engine.run()

"""I generated 1,000 random limit orders with stochastic arrival times, prices, and quantities to stress-test the matching engine under realistic order flow."""

# quick sanity checks, where len(trades)>0 and len(snapshots)~SIMULATION TIME
print("Total trades:", len(book.trades))
print("Total snapshots:", len(engine.l1_snapshots))

tape_df = pd.DataFrame(book.tape)
l1_df = pd.DataFrame(engine.l1_snapshots)

"""Sanity Checks Before Plotting"""

# Prices and quantities must be non-negative
assert (tape_df["price"] >= 0).all(), "Negative trade price"
assert (tape_df["qty"] > 0).all(), "Non-positive trade quantity"

# Spread must be non-negative
assert (l1_df["spread"] >= 0).all(), "Negative spread detected"

# Tape must be append-only (timestamps non-decreasing)
assert tape_df["time"].is_monotonic_increasing, "Tape is not ordered by time"

print("✅ Sanity checks passed")

"""Prepare Data for Plotting: Convert simulation time → datetime

(Note: Time is treated as seconds)
"""

tape_df["datetime"] = pd.to_datetime(tape_df["time"], unit="s")
tape_df = tape_df.set_index("datetime")

l1_df["datetime"] = pd.to_datetime(l1_df["time"], unit="s")
l1_df = l1_df.set_index("datetime")

"""Create OHLC Candles (from TAPE)"""

assert len(tape_df) > 0, "No trades → OHLC impossible"
assert isinstance(tape_df.index, pd.DatetimeIndex)

ohlc = tape_df[["price"]].copy()

ohlc["open"]  = ohlc["price"]
ohlc["high"]  = ohlc["price"]
ohlc["low"]   = ohlc["price"]
ohlc["close"] = ohlc["price"]

ohlc = ohlc[["open", "high", "low", "close"]]

# ohlc = tape_df["price"].resample("10s").ohlc().dropna()

volume = tape_df["qty"].resample("1min").sum()

"""Due to sparse trade activity in the simulated market, OHLC bars were constructed in event time, resulting in single-trade candles where open, high, low, and close coincid"""

ohlc = ohlc.dropna()

"""Validate candles"""

assert (ohlc["high"] >= ohlc["low"]).all()
assert (ohlc["high"] >= ohlc["open"]).all()
assert (ohlc["high"] >= ohlc["close"]).all()

plt.plot(tape_df.index, tape_df["price"])
plt.show()

"""Compute Rolling Volatility"""

l1_df["log_return"] = np.log(l1_df["mid"]).diff()
l1_df["rolling_vol"] = l1_df["log_return"].rolling(10).std()

"""CREATE THE PDF"""

with PdfPages("simulation_report.pdf") as pdf:

    # Page 1 — Price (from tape)
    fig, ax = plt.subplots(figsize=(10, 4))
    ax.plot(tape_df.index, tape_df["price"])
    ax.set_title("Trade Prices Over Time")
    ax.set_xlabel("Time")
    ax.set_ylabel("Price")

    plt.tight_layout()
    pdf.savefig(fig)
    plt.close()

    # Page 2 — Candlestick (OHLC, simplified)
    fig, ax = plt.subplots(figsize=(10, 4))
    ax.plot(ohlc.index, ohlc["close"])
    ax.set_title("10s OHLC (Close Price)")
    ax.set_xlabel("Time")
    ax.set_ylabel("Price")

    plt.tight_layout()
    pdf.savefig(fig)
    plt.close()

    # Page 3 — Spread over Time
    fig, ax = plt.subplots(figsize=(10, 4))
    ax.plot(l1_df.index, l1_df["spread"])
    ax.set_title("Bid–Ask Spread Over Time")
    ax.set_xlabel("Time")
    ax.set_ylabel("Spread")

    plt.tight_layout()
    pdf.savefig(fig)
    plt.close()

    # Page 4 — Rolling Volatility
    fig, ax = plt.subplots(figsize=(10, 4))
    ax.plot(l1_df.index, l1_df["rolling_vol"])
    ax.set_title("Rolling Mid-Price Volatility")
    ax.set_xlabel("Time")
    ax.set_ylabel("Volatility")

    plt.tight_layout()
    pdf.savefig(fig)
    plt.close()

    # Final confirmation
    print("simulation_report.pdf generated")